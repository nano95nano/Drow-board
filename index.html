<!doctype html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Realtime Drawing (Outline)</title>
<style>
  html,body,canvas { margin:0; padding:0; width:100%; height:100%; touch-action:none; }
  .ui { position:fixed; left:8px; bottom:8px; display:flex; gap:8px; }
  .btn { padding:8px 12px; border:1px solid #ccc; background:#fff; border-radius:8px; }
  .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; }
</style>
<body>
<canvas id="cv"></canvas>

<div class="ui">
  <button class="btn" id="joinBtn"><span class="dot" id="onlineDot" style="background:#aaa"></span><span id="status">オフライン</span></button>
  <button class="btn" data-color="#FF5A5A" style="color:#FF5A5A">赤</button>
  <button class="btn" data-color="#FFD166" style="color:#D49700">黄</button>
  <button class="btn" data-color="#06D6A0" style="color:#06D6A0">緑</button>
  <button class="btn" data-color="#118AB2" style="color:#118AB2">青</button>
  <button class="btn" data-color="#9D4EDD" style="color:#9D4EDD">紫</button>
</div>

<script>
/* =========================
   0) ユーティリティ
========================= */
const nowMs = () => performance.now(); // 同期/描画の共通“時間”

/* =========================
   1) ネットワーク窓口（ダミー）
   - あとで Photon SDK に差し替えるだけ
========================= */
const Networking = (() => {
  let handlers = { begin:()=>{}, append:()=>{}, end:()=>{}, presence:()=>{} };
  let connected = false, roomId = null;

  return {
    on: handlers, // 受信ハンドラを外から差し込む
    async connect(room) {
      // TODO: ここを Photon の接続＆ルーム参加に置き換える
      roomId = room; connected = true;
      handlers.presence({ count: 1 }); // 自分だけのダミー
      return true;
    },
    isConnected() { return connected; },
    sendBegin(meta) {
      // TODO: Photon RPC: BeginStroke(meta)
      // demo: 自分にもループバック（相手がいなくても形が分かる）
      setTimeout(()=>handlers.begin(meta), 0);
    },
    sendAppend(strokeId, batch) {
      // TODO: Photon RPC: AppendPoints(strokeId, batch)
      setTimeout(()=>handlers.append(strokeId, batch), 0);
    },
    sendEnd(strokeId) {
      // TODO: Photon RPC: EndStroke(strokeId)
      setTimeout(()=>handlers.end(strokeId), 0);
    }
  };
})();

/* =========================
   2) 描画モデル
========================= */
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
let W=0, H=0, DPR = Math.max(1, window.devicePixelRatio || 1);
function resize() {
  W = canvas.clientWidth; H = canvas.clientHeight;
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize, { passive:true }); resize();

const strokes = new Map(); // strokeId -> { color, width, points:[{x,y,t}], startMs, durationMs }
const my = { color: '#118AB2', width: 12, fadingSec: 30 };
let drawing = { active:false, id:null, lastSendMs:0, pending:[] };

function newId() { return Math.random().toString(36).slice(2); }

/* =========================
   3) 入力イベント（Pointer Events）
========================= */
canvas.addEventListener('pointerdown', (ev) => {
  ev.target.setPointerCapture(ev.pointerId);
  const id = newId();
  drawing.active = true;
  drawing.id = id;
  drawing.pending = [];
  const start = nowMs();
  const meta = {
    strokeId: id,
    color: my.color,
    width: my.width,
    startMs: start,
    durationMs: my.fadingSec * 1000
  };
  strokes.set(id, { ...meta, points: [] });
  Networking.sendBegin(meta);
  pushPoint(ev, start);
});

canvas.addEventListener('pointermove', (ev) => {
  if (!drawing.active) return;
  pushPoint(ev, nowMs());
});

canvas.addEventListener('pointerup', endStroke);
canvas.addEventListener('pointercancel', endStroke);

function endStroke() {
  if (!drawing.active) return;
  flushBatch(); // 送り残しを送る
  Networking.sendEnd(drawing.id);
  drawing.active = false;
  drawing.id = null;
  drawing.pending = [];
}

function pushPoint(ev, tMs) {
  const x = ev.offsetX, y = ev.offsetY;
  const s = strokes.get(drawing.id);
  if (!s) return;
  // 簡易間引き：前点との距離が小さければ捨てる
  const last = s.points[s.points.length - 1];
  if (last) {
    const dx = x - last.x, dy = y - last.y;
    if ((dx*dx + dy*dy) < 2*2) return; // 2px未満は捨てる
  }
  const tOffset = tMs - s.startMs;
  const pt = { x, y, t: tOffset };
  s.points.push(pt);
  drawing.pending.push(pt);

  // 10〜20msごとにまとめて送る（バッチ送信）
  const now = tMs;
  if (now - drawing.lastSendMs > 15) {
    flushBatch();
  }
}

function flushBatch() {
  if (!drawing.pending.length) return;
  Networking.sendAppend(drawing.id, drawing.pending);
  drawing.pending = [];
  drawing.lastSendMs = nowMs();
}

/* =========================
   4) 受信ハンドラ（相手→自分）
   - ここではダミーで自分に返ってくる
========================= */
Networking.on.begin = (meta) => {
  if (!strokes.has(meta.strokeId)) strokes.set(meta.strokeId, { ...meta, points: [] });
};
Networking.on.append = (strokeId, batch) => {
  const s = strokes.get(strokeId);
  if (!s) return;
  s.points.push(...batch);
};
Networking.on.end = (strokeId) => {/* 任意処理（閉じるフラグ等） */};
Networking.on.presence = ({ count }) => {
  onlineDot.style.background = count > 1 ? '#2ecc71' : '#aaa';
  status.textContent = count > 1 ? 'オンライン' : 'オフライン';
};

/* =========================
   5) レンダリング（時間で消える）
   - フェード“ヘッド”位置を時間で右へ進めるイメージ
========================= */
function render() {
  ctx.clearRect(0,0,W,H);
  const tNow = nowMs();

  for (const s of strokes.values()) {
    if (s.points.length < 2) continue;
    const life = s.durationMs;
    // 今の“消失ヘッド” = （現在時刻 - 開始時刻）
    const head = Math.max(0, tNow - s.startMs);

    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = s.width;
    // キラキラ簡易表現：合成を変えて重ね描き
    ctx.globalCompositeOperation = 'lighter';

    ctx.beginPath();
    let started = false;
    for (let i=0; i<s.points.length; i++) {
      const p = s.points[i];
      const next = s.points[i+1] || p;

      // p.t が head より古すぎる場合は完全に消える
      const age = head - p.t;
      const a = 1 - (age / life); // 1→0
      if (a <= 0) continue;

      ctx.globalAlpha = Math.min(1, Math.max(0, a));
      if (!started) { ctx.moveTo(p.x, p.y); started = true; }
      ctx.lineTo(next.x, next.y);
    }
    if (started) {
      ctx.strokeStyle = s.color;
      ctx.stroke();
    }

    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';

    // 寿命を完全に過ぎたら消す
    if (head - (s.points[s.points.length-1].t) > s.durationMs) {
      strokes.delete(s.strokeId);
    }
  }
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

/* =========================
   6) UI：色と接続
========================= */
document.querySelectorAll('.btn[data-color]').forEach(btn=>{
  btn.addEventListener('click', ()=> { my.color = btn.dataset.color; });
});

const joinBtn = document.getElementById('joinBtn');
const onlineDot = document.getElementById('onlineDot');
const status = document.getElementById('status');

joinBtn.addEventListener('click', async ()=>{
  let room = localStorage.getItem('roomId') || prompt('ルームコードを入力');
  if (!room) return;
  localStorage.setItem('roomId', room);
  await Networking.connect(room);
  // 本当はここでPhotonの参加者数を購読して presence を更新する
});
</script>
</body>
</html>
